#!/usr/bin/env python
# coding: utf-8

# app

# In[1]:


get_ipython().run_cell_magic('writefile', 'appteam3.py', '\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport datetime\nimport statsmodels.api as sm\nfrom dateutil.relativedelta import relativedelta\nfrom datetime import datetime\nimport plotly.express as px\n\nmigrant_App = pd.read_csv(\'migrant_clean.csv\', index_col=None)\ntimeseriesdf = pd.read_csv(\'timeseriesdf.csv\')\n#setting the index as a date for the timeseries\ntimeseriesdf[\'date\'] = pd.to_datetime(timeseriesdf[\'date\'])\ntimeseriesdf.set_index(\'date\', inplace=True)\n\ncolumn_names = migrant_App.columns\nprint(column_names)\n\nst.set_page_config(page_title="Migrant Web App", page_icon=":tada:", layout="wide")\n\n# Header Section\nst.subheader("Hi everyone, we are Team 3")\nst.title("Migrant Data Analysis")\nst.write("This is data analysis on Migrant Dataset from Team 3")\n\n# Sidebar\nst.sidebar.header("User Inputs")\nplanned_migration_date = st.sidebar.date_input("Input planned migration date", value="today", min_value=None, max_value=None, format="YYYY-MM-DD")\n\nmigration_route = st.sidebar.selectbox("Select Migration Route", timeseriesdf["migration route"].unique())\n\n# region_of_origin = st.sidebar.selectbox("Select Region of Origin", migrant_App["region of origin"].unique())\n# number_of_males = st.sidebar.number_input("Number of Males", min_value=0)\n# incident_year = st.sidebar.slider("Select Incident Year", 2014, 2023)\n\n# Main content\nst.header("Migrant Data Prediction")\n\n# Group data by "Region of Origin"\n# grouped_data = migrant_App.groupby("region of origin group").agg({\n#     "number of males": "sum",\n#     "number of females": "sum",\n#     "number of children": "sum",\n#     "total number of dead and missing": "sum"\n# })\n\n# # Display the aggregated data\n# st.write("Aggregated Data by Region:")\n# st.write(grouped_data)\n\n# # Plot the results (you can customize the chart type)\n# st.bar_chart(grouped_data)\n\n\n# User inputs\nst.write("User Inputs:")\nst.write(f"Planned Migration Date: {planned_migration_date}")\n# st.write(f"Incident Year: {incident_year}")\n# st.write(f"Region of Origin: {region_of_origin}")\n# st.write(f"Number of Males: {number_of_males}")\n\n# # Filter data based on user inputs\n# filtered_data = migrant_App[(migrant_App["incident year"] == incident_year) &\n#                             (migrant_App["region of origin group"] == region_of_origin) &\n#                             (migrant_App["number of males"] == number_of_males)]\n\n\n# if not filtered_data.empty:\n#     # Display data\n#     st.subheader("Analysis Results")\n#     st.write("number of dead:", filtered_data["number of dead"].values[0])\n#     st.write("estimated number of missings:", filtered_data["minimum estimated number of missing"].values[0])\n#     st.write("Number of Dead and Missing:", filtered_data["total number of dead and missing"].values[0])\n#     st.write("Number of Survivors:", filtered_data["number of survivors"].values[0])\n#     st.write("Number of Females:", filtered_data["number of females"].values[0])\n#     st.write("Number of Children:", filtered_data["number of children"].values[0])\n#     st.write("Cause of Death:", filtered_data["cause of death category"].values[0])\n#     st.write("Country of Death:", filtered_data["extracted country"].values[0])\n# else:\n#     st.warning("No data available for the selected inputs.")\n\n# Additional features..............\n\n#timeseries model \nst.subheader("Time Series Model")\n#function that returns the level of the migration route inputted\ndef getLevelOfRoute(route, timeseriesdf):\n    level = timeseriesdf[timeseriesdf[\'migration route\'] == route][\'label_level\'].values[0]\n    return level\n\n#run the function with the migration route inputted   \nts_level = getLevelOfRoute(migration_route, timeseriesdf)\n\nst.write(f"The migration route was classified as a danger {ts_level}.")\n\n#function to get all the df entries with the same level \ndef getClusterLabel(level, timeseries):\n    return (timeseries[timeseries[\'label_level\'] == level])\n\n#function that extracts all the routes in the same cluster and groups them by the target variable.\ndef preprocess_level_timeseries(level, timeseries):\n    # Get the \'level\' timeseries\n    level_timeseries = getClusterLabel(level, timeseries)\n    \n    # Drop the \'date\' column\n    level_timeseries = level_timeseries.drop([\'date.1\'], axis=1)\n    \n    # Group by date and sum the \'total number of dead and missing\'\n    level_timeseries = level_timeseries.groupby(level_timeseries.index)[\'total number of dead and missing\'].sum()\n    \n    return level_timeseries\n\nleveldf = preprocess_level_timeseries(ts_level, timeseriesdf)\n\n\n#the parameters will depend on the level selected \n#if ts_level = \'level1\' then app_order = (1, 1, 1) \n#if ts_level = \'level2\' or ts_level = \'level5\' then app_order = (1, 0, 0) \n#if ts_level = \'level3\' or ts_level = \'level4\' then app_order = (0, 1, 1) \nif ts_level == \'level1\':\n    app_order = (1, 1, 1)\nelif ts_level == \'level2\' or ts_level == \'level5\':\n    app_order = (1, 0, 0)\nelif ts_level == \'level3\' or ts_level == \'level4\':\n    app_order = (0, 1, 1)\n\n#function that gets the number of periods for the sarima model \n\ndef calculate_months_difference(date1, date2):\n    date1 = pd.to_datetime(date1, format="%Y-%m-%d")\n    date2 = pd.to_datetime(date2, format="%Y-%m-%d")\n\n    rdelta = relativedelta(date2, date1)\n    months_difference = rdelta.years * 12 + rdelta.months\n\n    return months_difference\n\nlast_date = leveldf.index[-1]\ntarget_date = planned_migration_date\nmonths_difference = calculate_months_difference(last_date, target_date)\n\n\n#function that sets the sarima timeseries model \ndef sarima_forecast(level_timeseries,forecast_months, order, seasonal_order, plot_title="SARIMA Forecast"):\n    # Create the SARIMA model\n    level_sarima_model = sm.tsa.SARIMAX(level_timeseries, order=order, seasonal_order=seasonal_order)\n    level_sarima_model_fit = level_sarima_model.fit()\n\n    # Make forecasts\n    forecasts = level_sarima_model_fit.get_forecast(steps=forecast_months)\n    predicted_values = forecasts.predicted_mean\n    predicted_values.index = pd.date_range(start=last_date, periods=forecast_months, freq=\'M\')\n\n\n\n\n    return predicted_values\n#run the sarima function\npredicted_values = sarima_forecast(leveldf, months_difference, order=app_order, seasonal_order=(1, 1, 1, 12), plot_title="Migrant Incident Forecast")\n\n\n#function to retrieve the output of the timeseries for the inputted date\ndef get_values_for_year_month(indexes, values, year, month):\n    matching_values = []\n    for i, date_index in enumerate(indexes):\n        if date_index.year == year and date_index.month == month:\n            matching_values.append(values[i])\n    return matching_values\n\n# Example usage:\nyear_to_find = planned_migration_date.year\nmonth_to_find = planned_migration_date.month\nmatching_values = get_values_for_year_month(predicted_values.index, predicted_values, year_to_find, month_to_find)\nst.write(f"Estimated number of incidents for the planned migration date: {matching_values}")\n\n\n\n# Plot the observed and forecasted values\nfig, ax = plt.subplots(figsize=(10, 6))\nax.plot(leveldf.index, leveldf, label=\'Historical Data\')\nax.plot(predicted_values.index, predicted_values, label=\'SARIMA Forecast\', color=\'red\')\nax.legend()\nax.set_title("Migrant Incident Forecast")\nst.pyplot(fig)\n\n# Create a time slider\ntime_range = st.slider("Select a time range", 0, 14, (0, 23))\n \n# Update the datetime slider based on the selected time range\nstart_date = datetime(2014, 1, 1, time_range[0])\nend_date = datetime(2025, 12, 30)\n#end_date = start_date + timedelta(hours=time_range[1] - time_range[0])\n \n# selected_date = slider_placeholder.slider(\n#     "Select a date range",\n#     min_value=start_date,\n#     max_value=end_date,\n#     value=(start_date, end_date),\n#     step=timedelta(hours=1),\n# )\n\n#link to slider code i found https://docs.kanaries.net/topics/Python/streamlit-datetime-slider\n\n\n\n#visualizing COD\nst.title(\'Cause of Death per migration route\')\n\n# Creates route selection dropdown\nmigration_routes = migrant_App[\'migration route\'].unique()\nselected_route = st.selectbox(\'Please Select a Migration Route\', migration_routes)\n\n# Filters the data based on the selected migration route\nfiltered_data = migrant_App[migrant_App[\'migration route\'] == selected_route]\n\n# Creates the histogram\nst.subheader(f\'Causes of Death for {selected_route}\')\nfig = px.histogram(filtered_data, x=\'cause of death category\')\nst.plotly_chart(fig)\n\n\n\n# Footer\nst.sidebar.text("Â© 2023 Migrant Data Analysis App")\n')


# In[ ]:


get_ipython().system("streamlit run appteam3.py --server.port=8080 --browser.serverAddress='0.0.0.0'")


# <a style='text-decoration:none;line-height:16px;display:flex;color:#5B5B62;padding:10px;justify-content:end;' href='https://deepnote.com?utm_source=created-in-deepnote-cell&projectId=214c1ac0-63c0-4792-9e34-2c8e1410bb21' target="_blank">
# <img alt='Created in deepnote.com' style='display:inline;max-height:16px;margin:0px;margin-right:7.5px;' src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iODBweCIgaGVpZ2h0PSI4MHB4IiB2aWV3Qm94PSIwIDAgODAgODAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDU0LjEgKDc2NDkwKSAtIGh0dHBzOi8vc2tldGNoYXBwLmNvbSAtLT4KICAgIDx0aXRsZT5Hcm91cCAzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkxhbmRpbmciIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJBcnRib2FyZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEyMzUuMDAwMDAwLCAtNzkuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjM1LjAwMDAwMCwgNzkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0yMCIgZmlsbD0iIzAyNjVCNCIgcG9pbnRzPSIyLjM3NjIzNzYyIDgwIDM4LjA0NzY2NjcgODAgNTcuODIxNzgyMiA3My44MDU3NTkyIDU3LjgyMTc4MjIgMzIuNzU5MjczOSAzOS4xNDAyMjc4IDMxLjY4MzE2ODMiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNS4wMDc3MTgsODAgQzQyLjkwNjIwMDcsNzYuNDU0OTM1OCA0Ny41NjQ5MTY3LDcxLjU0MjI2NzEgNDguOTgzODY2LDY1LjI2MTk5MzkgQzUxLjExMjI4OTksNTUuODQxNTg0MiA0MS42NzcxNzk1LDQ5LjIxMjIyODQgMjUuNjIzOTg0Niw0OS4yMTIyMjg0IEMyNS40ODQ5Mjg5LDQ5LjEyNjg0NDggMjkuODI2MTI5Niw0My4yODM4MjQ4IDM4LjY0NzU4NjksMzEuNjgzMTY4MyBMNzIuODcxMjg3MSwzMi41NTQ0MjUgTDY1LjI4MDk3Myw2Ny42NzYzNDIxIEw1MS4xMTIyODk5LDc3LjM3NjE0NCBMMzUuMDA3NzE4LDgwIFoiIGlkPSJQYXRoLTIyIiBmaWxsPSIjMDAyODY4Ij48L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMCwzNy43MzA0NDA1IEwyNy4xMTQ1MzcsMC4yNTcxMTE0MzYgQzYyLjM3MTUxMjMsLTEuOTkwNzE3MDEgODAsMTAuNTAwMzkyNyA4MCwzNy43MzA0NDA1IEM4MCw2NC45NjA0ODgyIDY0Ljc3NjUwMzgsNzkuMDUwMzQxNCAzNC4zMjk1MTEzLDgwIEM0Ny4wNTUzNDg5LDc3LjU2NzA4MDggNTMuNDE4MjY3Nyw3MC4zMTM2MTAzIDUzLjQxODI2NzcsNTguMjM5NTg4NSBDNTMuNDE4MjY3Nyw0MC4xMjg1NTU3IDM2LjMwMzk1NDQsMzcuNzMwNDQwNSAyNS4yMjc0MTcsMzcuNzMwNDQwNSBDMTcuODQzMDU4NiwzNy43MzA0NDA1IDkuNDMzOTE5NjYsMzcuNzMwNDQwNSAwLDM3LjczMDQ0MDUgWiIgaWQ9IlBhdGgtMTkiIGZpbGw9IiMzNzkzRUYiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+' > </img>
# Created in <span style='font-weight:600;margin-left:4px;'>Deepnote</span></a>
